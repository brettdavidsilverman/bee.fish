#ifndef BEE_FISH_QUERY_H
#define BEE_FISH_QUERY_H

#include <string>
#include <vector>
#include <iostream>
#include "../Miscellaneous/Debug.hpp"
#include <sstream>
#include <ostream>
#include <chrono>

#include "version.h"
#include "../Miscellaneous/Miscellaneous.hpp"
#include "../parser/parser.h"
#include "../Script/Variable.hpp"


namespace BeeFishQuery {
using namespace BeeFishBString;
using namespace BeeFishScript;
using namespace BeeFishParser;

    
class Query : public Match {
public:
    
    class BlankspaceCharacter :
        public BeeFishParser::Or
    {
    public:
        BlankspaceCharacter() : Or(
            new BeeFishParser::Character(" "),
            new BeeFishParser::Character("\t"),
            new BeeFishParser::Character("\r"),
            new BeeFishParser::Character("\n")
        )
        {
        }
    };
    
    class Blankspaces :
        public Repeat<BlankspaceCharacter>
    {
    public:
        Blankspaces(Size minimum = 0) : Repeat(minimum) {
        }
        
    };
    
    class Operator : public BeeFishParser::Or
    {
    public:
        Operator(
            const BString& word,
            const BString& letter
        ) : BeeFishParser::Or(
                new BeeFishParser::Character(letter),
                new BeeFishParser::And(
                    new Query::Blankspaces(),
                    new BeeFishParser::CIWord(word),
                    new Query::Blankspaces()
                )
            )
        {
        }
        
    };
    
    class And : public Operator
    {
    public:
        And() : Operator("and", "+")
        {
        }
        
    };
    
    class Or : public Operator
    {
    public:
        Or() : Operator("or", "|")
        {
        }
        
    };
    
    class Not : public Operator
    {
    public:
        Not() : Operator("not", "-")
        {
        }
        
    };
    
    class Punctuation : public BeeFishParser::Or
    {
    public:
        Punctuation() : Or(
            
            new BeeFishParser::Character("("),
            new BeeFishParser::Character(")"),
            new Query::Blankspaces(1),
            new Query::And(),
            new Query::Or(),
            new Query::Not()
        )
        {
        }
    };
    

    
    class TokenCharacter : public BeeFishParser::Not
    {
    public:
        TokenCharacter() :
            BeeFishParser::Not(
                new Punctuation()
            )
        {
        }
        
    };
    
    class Token : public BeeFishParser::And
    {
    protected:
        BString _value;
    public:
        Token() : BeeFishParser::And(
            new Query::Blankspaces(),
            new Capture(
                new Repeat<TokenCharacter>(1),
                _value
            ),
            new Query::Blankspaces()
        
        )
        {
        }
        
        virtual void success() {
            cout << "*" << value() << "*" << endl;
            And::success();
        }
        
        const BString& value() const {
            return _value;
        }

        
    };
    
    
    
    
    template<typename T>
    class Bracketed : public BeeFishParser::And
    {
    public:
        Bracketed() : BeeFishParser::And(
           // new Blankspace(),
            new BeeFishParser::Character("("),
            new Query::Blankspaces(),
            new LoadOnDemand<T>(),
            new Query::Blankspaces(),
            new BeeFishParser::Character(")"),
            new Query::Blankspaces()
        )
        {
        }
    };
        
    class Expression : public BeeFishParser::And
    {
        
    public:
        Expression()
        : BeeFishParser::And(
            new Query::Blankspaces(),
            new OrderOfPrecedence(
                
        {
            {
                // not token
                new BeeFishParser::And(
                    new Query::Not(),
                    new Token()
                )
            },
            
            {
                // not (expression)
                new BeeFishParser::And(
                    new Query::Not(),
                    new LoadOnDemand<Expression>()
                )
            },
            
            {
                // not (expression)
                new BeeFishParser::And(
                    new Query::Not(),
                    new Bracketed<Expression>()
                )
            },
            {
                // token and expression
                new BeeFishParser::And(
                    new Token(),
                    new Query::And(),
                    new LoadOnDemand<Expression>()
                ),
            
                // token or expression
                new BeeFishParser::And(
                    new Token(),
                    new Query::Or(),
                    new LoadOnDemand<Expression>()
                )
                
            },
            {
                // (expression) and token
                new BeeFishParser::And(
                    new Bracketed<Expression>(),
                    new Query::And(),
                    new Token()
                ),

                // (expression) or expression
                new BeeFishParser::And(
                    new Bracketed<Expression>(),
                    new Query::Or(),
                    new Token()
                )
                
                
            },
            
            {
                // (expression) and expression
                new BeeFishParser::And(
                    new Bracketed<Expression>(),
                    new Query::And(),
                    new LoadOnDemand<Expression>()
                ),

                // (expression) or expression
                new BeeFishParser::And(
                    new Bracketed<Expression>(),
                    new Query::Or(),
                    new LoadOnDemand<Expression>()
                )
                
                
            },
            {
                // (expression) and (expression)
                new BeeFishParser::And(
                    new Bracketed<Expression>(),
                    new Query::And(),
                    new Bracketed<Expression>()
                ),

                // (expression) or (expression)
                new BeeFishParser::And(
                    new Bracketed<Expression>(),
                    new Query::Or(),
                    new Bracketed<Expression>()
                )
                
                
            },

       
            {
                // (expression)
                new Bracketed<Expression>(),
            },
            /*
            {
                // (expression)
                new Bracketed<Token>(),
            },
            */
            
            {
                // token
                new Token()
            }
                 
        }
        
        )
        )
        {

        }
    

    };
    
public:
    Expression* _expression;
    
    Query() : Match()
    {
        _expression = new Expression();
        _match = _expression;
    }
    
};

}

#endif